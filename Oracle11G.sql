SELECT METADA FROM SYS.KOPM$; -- Verificando ambiente para saber quantos bits tem

/*
B023 = 32Bits
B047 = 64Bits
*/

-- Dicionario de Dados

Select* from dict; -- Ver o dicionario todo

-- Instancia Unica - RAC

Select PARALLEL from V$INSTANCE; -- Tudo que vier com v$ significa view

/*
A query acima esta perguntando se esta sendo usado paralelismo se a resposta for:
NO - Entao é instancia unico
YES - Entao não é instancia unica
*/

-- Estrutura de Memoria

SELECT COMPONENT, CURRENT_SIZE, MIN_SIZE, MAX_SIZE FROM V$SGA_DYNAMIC_COMPONENTS;

-- Conectando a outro Banco de Dados

SQLPLUS SYSTEM/SENHA@NOMEDOBANCO
ORACLE_SID=BANCO001


-- Nome do Banco para mostrar qual banco esta utilizando

SELECT NAME FROM V$DATABASE

/*
Armazenamnto
LÓGICO -> TABLESPACES -> SEGMENTOS(OBJETOS) -> EXTENSÕES(ESPAÇO) -> BLOCOS(DO SO)

FISICO -> DATAFILES
*/

-- NAO PODEMOS DETERMINAR EM QUAL ARQUIVO FISICO UM OBJETO FICARÁ

-- CRIANDO TABELA

CREATE TABLE cursos(
  ID_CURSO ITN PRIMARY KEY,
  NOME VARCHAR2(30),
  CARGA INT
)TABLESPACE USERS;

CREATE TABLE teste(
  ID_TESTE INT,
  NOME VARCHAR2(30)
);


SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES;

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'cursos';

SELECT TABLE_NAME, TABLESPACE_NAME
FROM USER_TABLES
WHERE TABLE_NAME = 'teste';

-- Todo objeto é criado por padrao na tablespace user, exceto quando se esta logado com o usuario system, entao o objeto sera criado na tablespace system

SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME, BYTES, BLOCKS, EXTENTS FROM SEGMENT_NAME;

SELECT SEGMENT_NAME, SEGMENT_TYPE, TABLESPACE_NAME, BYTES, BLOCKS, EXTENTS FROM USER_SEGMENT WHERE SEGMENT_NAME = 'cursos';

-- Fazendo Backup
/*
1- Criar uma pasta nova Data
2- CREATE TABLESPACE RECURSOS_HUMANOS
DATAFILE 'colocar caminho da pasta nova' ex: 'C:/DATA/RH_01.dbf
SIZE 100M AUTOEXTEND
ON NEXT 100M
MAXSIZE 4096M
*/


 -- Adicionando talespace
 
ALTER TABLESPACE NOME
ADD DATAFILE 'C:/DATA/RH_02.dbf'
SIZE 200M AUTOEXTEND
ON NEXT 200M
MAXSIZE 4096M;

-- Verificando a tablespace no dicionario de dados

SELECT TABLESPACE_NAME, FILE_NAME FROM DBA_DATA_FILES;

-- SEQUENCE -sequence é uma coluna auto increment, mas a sequence nao faz parte da tabela e sim do banco de dados inteiro
-- DESSA FORMA O UMA TABELA CONTINUA A SEQUENCE DE OUTRA

CREATE SEQUENCE SEQ_GERAL
START WITH 100
INCREMENT BY 10;

 ex: tabela A 100, 120...
 Tabela B 110, 130...
 

-- Criando tabela na Tablespace

CREATE TABLE FUNCIONARIOS(
IDFUNCIONARIO INT PRIMARY KEY
NOME VARCHAR2(30) -- VARCHARE É IGUAL AO VARCHAR MAS POSSUI MAIS CAPACIDADE
)TABLESPACE RECURSOS_HUMANOS;

INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'JOAO');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'CAIO');
INSERT INTO FUNCIONARIOS VALUES(SEQ_GERAL.NEXTVAL, 'MARIA');

SELECT * FROM FUNCIONARIOS;

-- COMMIT É SALVAR TUDO O QUE FOPI FEITO


-- CRIANDO TABLESPACE DE MKT

ALTER TABLESPACE MKT
ADD DATAFILE 'C:/DATA/MKT_01.dbf'
SIZE 200M AUTOEXTEND
ON NEXT 200M
MAXSIZE 4096M;


CREATE TABLE CAMPANHAS(
IDCAMPANHA INT PRIMARY KEY
NOME VARCHAR2(30) -- VARCHARE É IGUAL AO VARCHAR MAS POSSUI MAIS CAPACIDADE
)TABLESPACE MKT;

INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'PRIMAVERA');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'VERAO');
INSERT INTO CAMPANHAS VALUES(SEQ_GERAL.NEXTVAL, 'INVERNO');

SELECT * FROM CAMPANHAS;

-- cOLOCANDO TABLESPACE OFFLINE

ALTER TABLE RECURSOS_HUMANOS OFFLINE;

-- APONTAR PARA DICIONARIO DE DADOS

ALTER TABLESPACE RECURSOS_HUMANOS 
RENAME DATAFILE 'C:/DATA/RH_01.dbf' TO 'C:/PRODUCAO/RH_01.dbf';

-- TORNANDO TABLESPACE ONLINE

ALTER TABLE RECURSOS_HUMANOS ONLINE;


-- PseudColunas
	-- ROWID
	-- ROWNUM

CREATE TABLE ALUNO(
IDALUNO INT PRIMARY KEY,
NOME VARCHAR2(30),
EMAIL VARCHAR2(30),
SALARIO NUMBER(10,2)
);

CREATE SEQUENCE SEQ_EXEMPLO;

INSERT INTO ALUNO VALUES(SEQ_EXEMPLO.NEXTVAL, 'JOAO', 'JOAO@GMAIL.COM', 1000.00);

INSERT INTO ALUNO VALUES(SEQ_EXEMPLO.NEXTVAL, 'CELIA', 'CELIA@GMAIL.COM', 2000.00);

INSERT INTO ALUNO VALUES(SEQ_EXEMPLO.NEXTVAL, 'AMANDA', 'AMANDA@GMAIL.COM', 3000.00);

CREATE TABLE ALUNO2(
IDALUNO INT PRIMARY KEY,
NOME VARCHAR2(30),
EMAIL VARCHAR2(30),
SALARIO NUMBER(10,2)
);

INSERT INTO ALUNO2 VALUES(SEQ_EXEMPLO.NEXTVAL, 'TOM', 'JOAO@GMAIL.COM', 1000.00);

INSERT INTO ALUNO2 VALUES(SEQ_EXEMPLO.NEXTVAL, 'MARIA', 'CELIA@GMAIL.COM', 2000.00);

INSERT INTO ALUNO2 VALUES(SEQ_EXEMPLO.NEXTVAL, 'CLAUDIA', 'AMANDA@GMAIL.COM', 3000.00);


-- ROWID - ENDEREÇO FISICO DOS REGISTROS
	
SELECT ROWID, IDALUNO, NOME, EMAIL FROM ALUNO;


-- ROWNUM - PAGINAR REGISTROS

SELECT ROWID, ROWNUM, IDALUNO, NOME, EMAIL FROM ALUNO;

SELECT ROWID, ROWNUM, IDALUNO, NOME, EMAIL FROM ALUNO2;


-- PROCEDURE

CREATE OR REPLACE PROCEDURE BONUS(P_IDALUNO ALUNO.IDALUNO%TYPE, P_PERCENT NUMBER)
AS
	BEGIN
			UPDATE ALUNO SET SALARIO = SALARIO + (SALARIO *(P_PERCENT/100))
			WHERE P_IDALUNO = P_IDALUNO;
	END;
	/

SELECT * FROM ALUNO;

CALL AUMENTO(3,10);  -- (ID DO ALUNO, AUMENTO)



-- TRIGGERS

	-- insert, delete, update
	-- 2 formas
		-- 1 - Programação dentro da trigger
				-- Mais limitada
		-- 2 - Por meio de uma procedure
				-- Trigger chama a procedure

	-- Triggers devem ter o tamanho de ate 32k
	-- nao executam comandos de DIL -  commi, rollback e savepoint

CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW -- PARA CADA LINHA Q OBEDECER A CONDIÇAO
BEGIN
	IF : NEW.SALARIO > 2000 THEN
		RAISE_APPLICATION_ERROR(20000, 'VALOR INCORRETO')
	END IF;
END;
/

CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW -- PARA CADA LINHA Q OBEDECER A CONDIÇAO
BEGIN
	IF : NEW.SALARIO > 2000 THEN
		RAISE_APPLICATION_ERROR(20000, 'VALOR INCORRETO');
	END IF;
END;
/


CREATE OR REPLACE TRIGGER CHECK_SALARIO
BEFORE INSERT OR UPDATE ON ALUNO
FOR EACH ROW
BEGIN
	IF :NEW.SALARIO < 2000 THEN
		RAISE_APPLICATION_ERROR(20000, 'VALOR INCORRETO');
	END IF;
END;
/


INSERT INTO ALUNO VALUES(SEQ_EXEMPLO.NEXTVAL, 'BOB', 'BOB@GMAIL.COM', 100.00); -- VAI DAR ERRO, POIS SALARIO MENOR Q 2000


SELECT TRIGGER_NAME, TRIGGER_BODY FROM USER_TRIGGERS; 


-- TRIGGER DE EVENTO

CREATE TABLE AUDITORIA(
	DATA_LOGIN DATE,
	LOGIN VARCHAR2(30)
);

CREATE OR REPLACE PROCEDURE LOGPROC IS 
BEGIN
	INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN)
	VALUES(SYSDATE, USER);
END LOGPROC;
/

SELECT SYSDATE FROM DUAL;

SELECT USER FROM DUAL;


CREATE OR REPLACE TRIGGER LOGTRIGGER 
AFTER LOGON ON DATABASE
CALL LOGPROC
/

-- FALHA DE LOGON

CREATE OR REPLACE TRIGGER FALHA_LOGON 
AFTER SERVERERROR
ON DATABASE
BEGIN
	IF (IS_SERVERERROR(1017)) THEN
		INSERT INTO AUDITORIA(DATA_LOGIN, LOGIN)
		VALUES(SYSDATE, 'ORA-1017');
	END IF;
END FALHA_LOGON;
/


-- TRIGGER DE DML

CREATE TABLE USUARIO(
	ID INT,
	NOME VARCHAR2(30)
);

CREATE TABLE BKP_USER(
	ID INT,
	NOME VARCHAR2(30)
);


INSERT INTO USUARIO VALUES (1, 'JOAO');
INSERT INTO USUARIO VALUES (2, 'MAYA');
COMMIT;

CREATE OR REPLACE TRIGGER LOG_USUARIO
BEFORE DELETE ON USUARIO
FOR EACH ROW
BEGIN
	INSERT INTO BKP_USER VALUES
	(:OLD.ID, :OLD.NOME);
END;
/

DELETE FROM USUARIO WHERE ID = 1;

SELECT * FROM BKP_USER;

-- Trabalhando com Views
			   
CREATE TABLE CLIENTE(
	IDCLIENTE INT PRIMARY KEY,
	NOME VARCHAR2(30),
	SEXO CHAR(1)
	);

INSERT INTO CLIENTE VALUES(1007, 'BOB', 'M');
			   
COMMIT;
			   
SELECT * FROM CLIENTE;			   
			   
CREATE OR REPLACE VIEW V_CLIENTE
AS 
	SELECT IDCLIENTE, NOME, SEXO
	FROM CLIENTE;
			   
INSERT INTO V_CLIENTE VALUES(1008, 'MARIA', 'F');
			   		   
SELECT * FROM CLIENTE;	
SELECT * FROM V_CLIENTE;				   
			   
			   
CREATE OR REPLACE VIEW V_CLIENTE_RO
AS 
	SELECT IDCLIENTE, NOME, SEXO
	FROM CLIENTE			   
	WITH READ ONLY;
-- nao é possivel fazer insert no read only, ira da erro caso tente
			   
-- View de Join
			   
CREATE OR REPLACE VIEW RELATORIO
AS 
	SELECT IDCLIENTE, NOME, SEXO
	FROM CLIENTE			   
	INNER JOIN TELEFONE
	ON IDCLIENTE = ID_CLIENTE;
			   
-- FORCE -- UMA VIEW SERA CRIADA MAS COM ERRO DE COMPILAÇÃO, POIS A TABELA TELEFONE AINDA N EXISTE
			   
CREATE OR REPLACE FORCE VIEW RELATORIO
AS 
	SELECT IDCLIENTE, NOME, SEXO
	FROM CLIENTE			   
	INNER JOIN TELEFONE
	ON IDCLIENTE = ID_CLIENTE;			   
			   
CREATE TABLE TELEFONE(
	IDTELEFONE INT PRIMARY KEY,
	NUMERO VARCHAR2(10),
	ID_CLIENTE INT
	);
			
ALTER TABLE TELEFONE ADD CONSTRAINT FK_CLIENTE_TELEFONE
FOREIGN KEY (ID_CLIENTE) REFERENCES CLIENTE; --ORACLE É INTELIGENTE E JA VAI DIRETO NA CHAVE PRIMARIA
			  
INSERT INTO TELEFONE VALUES(1, '123455678', 1007);
COMMIT;
SELECT * FROM RELATORIO			   

			   
-- DML - DATA MANIPULATION LANGUAGE			   
-- DEFERRABLE CONSTRAINTS	
	-- utilizado em inserção em massa
	-- diz se pode ser verificado na dtl

CREATE TABLE FUNCIONARIO(
	IDFUNCIONARIO INT CONSTRAINT PK_FUNCIONARIO PRIMARY KEY,
	NOME VARCHAR2(100)
	);
			   
CREATE TABLE TELEFONE2(
	IDTELEFONE INT PRIMARY KEY,
	NUMERO VARCHAR2(10),
	ID_FUNCIONARIO INT
	);
	
ALTER TABLE TELEFONE2 ADD CONSTRAINT FK_TELEFONE
FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO;
			 
			  
INSERT INTO FUNCIONARIO VALUES (1, 'JOSE');			   
INSERT INTO TELEFONE2 VALUES (10, '1234567890', 1);			   
			   
-- VERIFICANDO O ESTADO DA CONSTRAINT
			   
SELECT CONSTRAINT_NAME, DEFERRABLE, DEFERRED
FROM USAR_CONSTRAINT WHERE TABLE_NAME IN ('FUNCIONARIO', 'TELEFONE2');

-- APAGANDO CONSTRAINT
ALTER TABLE TELEFONE2 DROP CONSTRAINT FK_TELEFONE
			   
-- RECRIANDO CONSTRAINT
ALTER TABLE TELEFONE1 ADD CONSTRAINT FK_TELEFONE2
FOREIGN KEY (ID_FUNCIONARIO) REFERENCES FUNCIONARIO
DEFERRABLE; -- QUER DIZER QUE PODE SER ATRASDA, VERIFICADO SO NO DTL

			   
SELECT CONSTRAINT_NAME, DEFERRABLE AS ATRASADA , DEFERRED AS VERIFICACAO
FROM USAR_CONSTRAINT WHERE TABLE_NAME IN ('FUNCIONARIO', 'TELEFONE2');			   
			   
INSERT INTO TELEFOE2 VALUES (10, '0987654321', 10);			   
			   
-- MUDANDO PARA DTL --verificação ocorre na hora do commit

SET CONSTRAINT ALL DEFERRED;			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
			   
